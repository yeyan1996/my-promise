const PENDING = 'pending'
const RESOLVED = 'resolved'
const REJECTED = 'rejected'

const isFunction = obj => typeof obj === 'function'

// Resolve promise
function resolvePromise(promise2, value, resolve, reject) {
  // Prevent the case where a returned promise might call both resolve and reject
  let called
  // If there's circular reference, throw error through reject
  if (value === promise2) {
    reject(new TypeError('Chaining cycle detected for promise'))
  }

  // If value is pending, promise needs to stay in waiting state until value is executed or rejected
  // If value is in other states, handle Promise with the same value

  // As long as value has a then method, it can be resolved, regardless of whether value is object or function
  if (value && (typeof value === 'object' || typeof value === 'function')) {
    // Following cases need to be wrapped in try/catch
    // Because there might be cases where then method is defined as an accessor that throws an error
    try {
      const then = value.then
      if (typeof then === 'function') {
        // Here we need to use call to bind this direction to comply with a+ specification
        then.call(value,
          // Define how to expand this promise
          // Internally customized onFulfilled/onRejected functions for then method, specifying handling logic
          // When the returned promise is resolved, then resolve the promise(promise2) generated by this then method
          (res) => {
            if (called)
              return
            called = true
            // Recursively call resolvePromise until the passed value is not a promise object
            // Passing promise2 is to preserve promise2 through closure to prevent subsequent circular references
            resolvePromise(promise2, res, resolve, reject)
          }, (err) => {
            if (called)
              return
            called = true
            reject(err)
          })
      }
      else {
        // If it's an object but has no then method, resolve directly
        resolve(value)
      }
    }
    catch (e) {
      // In case of error, this promise2 needs to be rejected and locked to prevent multiple changes
      if (called)
        return
      called = true
      reject(e)
    }
  }
  else {
    resolve(value)
  }
}

class Promise {
  constructor(fn) {
    const resolve = (res) => {
      // resolve method can only be called once when promise is in pending state, state cannot be changed after resolution
      if (this.status === PENDING) {
        this.status = RESOLVED
        this.value = res
        // After calling resolve function, iterate through previously stored callbacks and execute them
        this.resolvedCallbacks.map(cb => cb())
      }
    }
    const reject = (err) => {
      // When calling reject method, promise can only be in pending state
      if (this.status === PENDING) {
        this.status = REJECTED
        this.value = err
        this.rejectedCallbacks.map(cb => cb())
      }
    }
    this.status = PENDING
    this.value = undefined
    // Store all callbacks when there are multiple then methods
    // promise.then(res1=>{code1....})
    // promise.then(res2=>{code2....})
    // promise.then(res3=>{code3....})
    this.resolvedCallbacks = []
    this.rejectedCallbacks = []

    try {
      fn(resolve, reject)
    }
    catch (e) {
      // Any possible error should execute reject
      reject(e)
    }
  }

  then(onFulfilled, onRejected) {
    // If then parameters are not functions, use default functions to continue passing promise chain
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : res => res
    onRejected = typeof onRejected === 'function'
      ? onRejected
      : (err) => {
          throw err
        }

    // Wrap the return value of then/catch into a promise, because then/catch ultimately returns a promise
    const promise2 = new Promise((resolve, reject) => {
      switch (this.status) {
        case PENDING: {
          // If promise is not resolved, store corresponding callbacks in array, waiting for resolve/reject to put callbacks in microtask queue
          // Callbacks must be called asynchronously here, in spec when a promise is resolved, stored callbacks array must be executed asynchronously
          // For pending promise, then method synchronously registers callbacks, but execution is asynchronous (async microtask)
          // (Compared to promises in other states where then method asynchronously resolves promise)
          this.resolvedCallbacks.push(
            // Implement through callbacks: when promise is resolved, execute previously registered callbacks in sequence
            () => {
              setTimeout(() => {
                try {
                  const res = onFulfilled(this.value)
                  resolvePromise(promise2, res, resolve, reject)
                }
                catch (e) {
                  reject(e)
                }
              })
            },
          )

          this.rejectedCallbacks.push(
            () => {
              setTimeout(() => {
                try {
                  const err = onRejected(this.value)
                  resolvePromise(promise2, err, resolve, reject)
                }
                catch (e) {
                  reject(e)
                }
              })
            },
          )

          break
        }

        case RESOLVED: {
          // After then method resolves promise with resolve/reject status, it will put callback function in microtask queue with resolved value as parameter
          // JS engine will automatically process tasks in microtask queue through EventLoop after current macrotask completes
          /** Use setTimeout to simulate microtask due to browser limitations */
          setTimeout(() => {
            try {
              // First execute user-defined onFulfilled code, assign return value to res
              const res = onFulfilled(this.value)
              resolvePromise(promise2, res, resolve, reject)
            }
            catch (e) {
              // If exception occurs in onFulFilled/onRejected, use exception info as value, change promise2 status to rejected
              reject(e)
            }
          })
          break
        }

        case REJECTED: {
          setTimeout(() => {
            try {
              const res = onRejected(this.value)
              resolvePromise(promise2, res, resolve, reject)
            }
            catch (e) {
              reject(e)
            }
          })
          break
        }
      }
    })
    // then/catch always returns a promise
    return promise2
  }

  catch(onRejected) {
    return this.then(null, onRejected)
  }

  // finally's callback won't accept any parameters
  // If finally's callback returns a promise, finally will wait for callback's promise to resolve before resolving itself
  // finally returns a promise, and promise's value is the resolved value of the first non-finally returned promise
  // (i.e. finally passes down the value of previous promise)
  finally(callback) {
    if (!isFunction(callback))
      callback = () => {}
    return this.then(
      res => Promise.resolve(callback()).then(() => res),
      err => Promise.resolve(callback()).then(() => {
        throw err
      }),
    )
  }

  static resolve(value) {
    // If promise object, synchronously expand and return directly
    if (value instanceof this) {
      return value
    }
    return new Promise((resolve, reject) => {
      // thenable object needs to be expanded asynchronously
      if (value && value.then && typeof value.then === 'function') {
        value.then(resolve, reject)
      }
      else {
        // Apart from above 2 cases, other cases synchronously generate a resolved state promise object
        resolve(value)
      }
    })
  }

  static reject(err) {
    return new Promise((resolve, reject) => {
      reject(err)
    })
  }

  static all(iterator) {
    // all's parameter must be an iterable data structure
    if (!iterator[Symbol.iterator])
      throw new Error('argument is not iterable')
    return new Promise((resolve, reject) => {
      // If parameter length is 0, directly return a synchronously resolved state promise
      if (!iterator.length) {
        resolve()
        return
      }
      const resolvedValues = []

      const onResolve = (res) => {
        resolvedValues.push(res)
        if (resolvedValues.length === iterator.length) {
          resolve(resolvedValues)
        }
      }

      iterator.map(item => Promise.resolve(item)).forEach((promise) => {
        promise.then(onResolve, reject)
      })
    })
  }

  static race(iterator) {
    if (!iterator[Symbol.iterator])
      throw new Error('argument is not iterable')
    return new Promise((resolve, reject) => { // If parameter length is 0, return a forever pending state promise
      if (!iterator.length) {
        return
      }
      iterator.map(item => Promise.resolve(item)).forEach((promise) => {
        promise.then(resolve, reject)
      })
    })
  }
}

try {
  module.exports = Promise

  // Test code
  Promise.defer = Promise.deferred = function () {
    const dfd = {}
    dfd.promise = new Promise((resolve, reject) => {
      dfd.resolve = resolve
      dfd.reject = reject
    })
    return dfd
  }
}
catch (e) {
  console.warn(e)
  console.warn('Please use node to run test code')
}
